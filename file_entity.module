<?php

/**
 * @file
 * Extends Drupal file entities to be fieldable and viewable.
 */

use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Field\FieldDefinition;
use Drupal\file\FileInterface;
use Drupal\file_entity\Entity\FileType;
use Drupal\file_entity\FileTypeInterface;

/**
 * Implements hook_entity_info_alter().
 *
 * Extends the core file entity to be fieldable. The file type is used as the
 * bundle key. File types are implemented as CTools exportables, so modules can
 * define default file types via hook_file_default_types(), and the
 * administrator can override the default types or add custom ones via
 * admin/structure/file-types.
 */
function file_entity_entity_type_alter(&$entity_types) {
  /** @var $entity_types \Drupal\Core\Entity\EntityTypeInterface[] */
  $entity_types['file']->set('fieldable', TRUE);
  $keys = $entity_types['file']->getKeys();
  $keys['bundle'] = 'type';
  $entity_types['file']->set('entity_keys', $keys);
  $entity_types['file']->set('bundle_entity_type', $keys);

  $entity_types['file']->setClass('Drupal\file_entity\FileEntity');
}

/**
 * Checks if pattern(s) match mimetype(s).
 */
function file_entity_match_mimetypes($needle, $haystack) {
  $needle = is_array($needle) ? $needle : array($needle);
  $haystack = is_array($haystack) ? $haystack : array($haystack);

  foreach ($haystack as $mimetype) {
    foreach ($needle as $search) {
      if (fnmatch($search, $mimetype) || fnmatch($mimetype, $search)) {
        return TRUE;
      }
    }
  }

  return FALSE;
}

/**
 * Returns an array of enabled file types.
 */
function file_type_get_enabled_types() {
  $types = FileType::loadMultiple();
  return array_filter($types, 'file_type_is_enabled');
}

/**
 * Returns TRUE if a file type is enabled, FALSE otherwise.
 */
function file_type_is_enabled(FileTypeInterface $type) {
  return $type->status();
}

/**
 * Implements hook_file_type().
 */
function file_entity_file_type(FileInterface $file) {
  $types = array();
  foreach (file_type_get_enabled_types() as $type) {
    if (file_entity_match_mimetypes($type->mimetypes, $file->getMimeType())) {
      $types[] = $type->id();
    }
  }
  return $types;
}

/**
 * Determines file type for a given file.
 *
 * @param \Drupal\file\FileInterface $file
 *   File object.
 *
 * @return string
 *   Machine name of file type that should be used for given file.
 */
function file_get_type(FileInterface $file) {
  $types = \Drupal::moduleHandler()->invokeAll('file_type', array($file));
  \Drupal::moduleHandler()->alter('file_type', $types, $file);

  return empty($types) ? NULL : reset($types);
}

/**
 * Implements hook_entity_base_field_info().
 */
function file_entity_base_field_info(EntityTypeInterface $entity_type) {
  if ($entity_type->id() == 'file') {
    $fields['type'] = FieldDefinition::create('string')
      ->setLabel(t('File type'))
      ->setDescription(t('The type of the file.'));

    return $fields;
  }

}

/**
 * Implements hook_entity_base_field_info().
 */
function file_entity_storage_field_info(EntityTypeInterface $entity_type) {
  if ($entity_type->id() == 'file') {
    $fields['type'] = FieldDefinition::create('string')
      ->setLabel(t('File type'))
      ->setDescription(t('The type of the file.'));

    return $fields;
  }
}


/**
 * The {file_managed}.type value when the file type has not yet been determined.
 */
define('FILE_TYPE_NONE', 'undefined');
